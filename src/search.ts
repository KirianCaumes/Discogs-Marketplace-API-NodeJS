import UserAgent from 'user-agents'
import { chromium as playwright, type Page } from 'playwright-chromium'
import Currency from 'data/currency.data'
import Country from 'data/country.data'
import scrape from 'scrape'
import type SearchParams from 'interfaces/search-params.interface'
import type SearchResult from 'interfaces/search-result.interface'

/**
 * Performs a search on the Discogs marketplace using the provided parameters.
 * @param pageInstance
 * Optional Playwright page instance to reuse for multiple requests. This can be useful for reducing overhead when making numerous requests.
 * If not provided, a new browser instance will be created and managed internally.
 * @returns A promise that resolves to the search results, including items found, pagination details, and the generated URL.
 */
export default async function search(
    {
        searchType = 'q',
        searchValue,
        currency,
        genre,
        style,
        format,
        formatDescription,
        condition,
        year,
        years,
        isMakeAnOfferOnly = false,
        from,
        seller,
        hoursRange,
        sort = 'listed,desc',
        limit = 25,
        page = 1,
        lang = 'en',
    }: SearchParams,
    pageInstance?: Page,
): Promise<SearchResult> {
    /** Url to be called by the browser */
    const url = [
        generateUrl({ searchType, seller, lang }),
        serializeParams({
            [searchType]: searchValue,
            currency,
            genre,
            style: style?.length ? style : null,
            format: format?.length ? format : null,
            format_desc: formatDescription?.length ? formatDescription : null,
            condition: condition?.length ? condition : null,
            year: year && !years ? year : null,
            year1: years?.min && !year ? years.min : null,
            year2: years?.max && !year ? years.max : null,
            offers: isMakeAnOfferOnly ? 1 : null,
            ships_from: from,
            hours_range: hoursRange,
            limit,
            page,
            sort,
        }),
    ].join('?')

    // Get browser page by user input or generate a new one
    const { browserPage, browser, browserContext } = pageInstance
        ? { browserPage: pageInstance }
        : await (async () => {
              /** Init browser */
              const browser = await playwright.launch({
                  args: ['--no-sandbox', '--disable-setuid-sandbox', '--disable-gl-drawing-for-tests'],
              })

              /** Init context */
              const browserContext = await browser.newContext({
                  userAgent: new UserAgent({ platform: 'Win32' }).toString(),
                  extraHTTPHeaders: {
                      'X-PJAX': 'true',
                  },
                  javaScriptEnabled: false,
              })

              /** Init page */
              const browserPage = await browserContext.newPage()

              return {
                  browser,
                  browserContext,
                  browserPage,
              }
          })()

    // Block all resources except document
    await browserPage.route('**/*', route =>
        [
            'stylesheet',
            'image',
            'media',
            'font',
            'script',
            'texttrack',
            'xhr',
            'fetch',
            'eventsource',
            'websocket',
            'manifest',
            'other',
        ].includes(route.request().resourceType())
            ? route.abort()
            : route.continue(),
    )

    // Inject some globals to the page, so we can use them in the scraping function
    await browserPage.addInitScript(g => Object.assign(globalThis, g), { Country, Currency })

    /** Init page */
    const response = await browserPage.goto(url, { waitUntil: 'domcontentloaded' })

    /** Status code from the page */
    const status = response?.status() ?? 500

    // See current issue: https://github.com/evanw/esbuild/issues/2605
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access
    await browserPage.evaluate(() => ((window as any).__name ??= (func: any) => func))

    // If error status, reject
    if (status >= 400) {
        const errorMessage =
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            (await browserPage.evaluate(() => document.querySelector('h1 + p')?.innerHTML.trim())) || `An error ${status} occurred.`

        // Close browser
        await browserContext?.close()
        await browser?.close()

        throw new Error(errorMessage)
    }

    /** Url generated by the browser */
    const urlGenerated = browserPage.url()

    // Scrape data from the page
    const { items, total } = await browserPage.evaluate(scrape)

    // Close browser
    await browserContext?.close()
    await browser?.close()

    return {
        items,
        result: {
            total,
            perPage: limit,
        },
        page: {
            current: page,
            total: Math.ceil(total / limit),
        },
        urlGenerated,
    }
}

/**
 * Generate URL to be parsed
 * @returns Url
 */
function generateUrl({
    searchType,
    seller,
    lang,
}: Required<Pick<SearchParams, 'searchType' | 'lang'>> & Pick<SearchParams, 'seller'>): string {
    const baseUrl = `https://www.discogs.com/${lang}`

    if (seller) {
        const path = searchType === 'user' ? 'mywants' : 'profile'
        return `${baseUrl}/seller/${seller}/${path}`
    } else {
        const path = searchType === 'user' ? 'mywants' : 'list'
        return `${baseUrl}/sell/${path}`
    }
}

/**
 * Serialize params URL
 * @param params Object of GET parameters
 * @returns Url
 */
function serializeParams(params: Record<string, unknown>): string {
    return Object.entries(params)
        .flatMap(([key, value]) => {
            if (value === undefined || value === null) {
                return []
            }

            if (Array.isArray(value)) {
                return value.map(v => `${key}=${encodeURIComponent(v as string)}`)
            }

            return [`${key}=${encodeURIComponent(value as string)}`]
        })
        .join('&')
}
