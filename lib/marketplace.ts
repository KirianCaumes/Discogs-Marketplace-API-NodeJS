import { ECurrency } from '@enum/ECurrency'
import { EFormat } from '@enum/EFormat'
import { EFormatDescription } from '@enum/EFormatDescription'
import { EFrom } from '@enum/EFrom'
import { EGenre } from '@enum/EGenre'
import { ELang } from '@enum/ELang'
import { EMediaCondition } from '@enum/EMediaCondition'
import { ESort } from '@enum/ESort'
import { EStyle } from '@enum/EStyle'
import { EType } from '@enum/EType'
import IInput from '@interface/IInput'
import IOutputError from '@interface/IOutputError'
import IOutputSuccess from '@interface/IOutputSuccess'
import IYears from '@interface/IYears'
import { TLimit } from '@type/TLimit'
import axios, { AxiosError, AxiosResponse } from 'axios'
import { JSDOM } from 'jsdom'
import UserAgent from 'user-agents'

/**
 * Discogs Marketplace 
 * @class
 * @implements {IInput}
 */
export default class Marketplace implements IInput {
    searchType: EType
    searchValue: string | number | undefined
    currency: ECurrency | undefined
    genre: EGenre | undefined
    style: EStyle[]
    format: EFormat[]
    formatDescription: EFormatDescription[]
    mediaCondition: EMediaCondition[]
    year: number | undefined
    years: IYears | undefined
    isAudioSample: boolean
    isMakeAnOfferOnly: boolean
    from: EFrom | undefined
    sort: ESort
    limit: TLimit
    page: number
    lang: ELang

    /**
     * Url generated by Axios
     */
    url: string | null

    constructor({
        searchType = EType.STRING,
        searchValue = undefined,
        currency = undefined,
        genre = undefined,
        style = [],
        format = [],
        formatDescription = [],
        mediaCondition = [],
        year = undefined,
        years = undefined,
        isAudioSample = false,
        isMakeAnOfferOnly = false,
        from = undefined,
        sort = ESort.LISTED_NEWEST,
        limit = 25,
        page = 1,
        lang = ELang.ENGLISH
    }: IInput) {
        this.searchType = searchType
        this.searchValue = searchValue
        this.currency = currency
        this.genre = genre
        this.style = style
        this.format = format
        this.formatDescription = formatDescription
        this.mediaCondition = mediaCondition
        this.year = year
        this.years = years
        this.isAudioSample = isAudioSample
        this.isMakeAnOfferOnly = isMakeAnOfferOnly
        this.from = from
        this.sort = sort
        this.limit = limit
        this.page = page
        this.lang = lang

        this.url = null
    }

    /**
     * Search elements on discogs
     * @returns {Promise<IOutputSuccess>} Items found
     */
    public async search(): Promise<IOutputSuccess> {
        return await new Promise((resolve, reject) => {
            axios.get(`https://www.discogs.com/${this.lang}/sell/${this.searchType === EType.USER ? 'mywants' : 'list'}`, {
                /** @type {any} Custom headers */
                headers: {
                    'User-Agent': (new UserAgent()).toString()
                },
                /** @type {any} Get parameters */
                params: {
                    [this.searchType]: this.searchValue,
                    currency: this.currency,
                    genre: this.genre,
                    style: this.style.length ? this.style : undefined,
                    format: this.format.length ? this.format[0] : undefined,
                    format_desc: this.formatDescription.length ? this.formatDescription[0] : undefined,
                    condition: this.mediaCondition.length ? this.mediaCondition[0] : undefined,
                    year: this.year && !this.years ? this.year : undefined,
                    year1: this.years?.min && !this.year ? this.years?.min : undefined,
                    year2: this.years?.max && !this.year ? this.years?.max : undefined,
                    audio: this.isAudioSample ? 1 : 0,
                    offers: this.isMakeAnOfferOnly ? 1 : 0,
                    ships_from: this.from?.length ? this.from : undefined,
                    limit: this.limit,
                    page: this.page,
                    sort: this.sort,
                },
                /** @function paramsSerializer Need to handle manually discogs params */
                paramsSerializer: (params: any): string => {
                    let param: string[] = []
                    for (let key in params) {
                        if (params[key] === undefined || params[key] === null) {
                            continue
                        } else if (Array.isArray(params[key])) {
                            /** Custom handle for array */
                            if (params[key].length > 0) {
                                for (const el of params[key]) {
                                    param.push(key + "=" + encodeURIComponent(el))
                                }
                            } else {
                                continue
                            }
                        } else {
                            param.push(key + "=" + encodeURIComponent(params[key]))
                        }
                    }
                    return param.join('&')
                }
            })
                .then((res: AxiosResponse) => {
                    const { data, request } = res
                    this.url = `${request.res.req.agent.protocol}//${request.res.connection._host}${request.path}`
                    let result: IOutputSuccess = this._format((new JSDOM(data)).window.document)
                    resolve(result)
                })
                .catch((err: AxiosError) => {
                    const { document } = (new JSDOM(err.response?.data)).window
                    let result: IOutputError = {
                        message: (document.querySelector('h1 + p')?.innerHTML?.trim() || err.response?.statusText) ?? 'An error occured',
                        code: err.response?.status
                    }
                    reject(result)
                })
        })
    }

    /**
     * Function to convert devise to ISO name
     * @param str String to clean
     * @returns {string} Cleanup string
     */
    private _convertDevise(str: string): string {
        if (!str) return str
        const data: any = {
            "\$US": "USD",
            "£GB": "GBP",
            "€": "EUR",
            "\$CA": "CAD",
            "$AU": "AUD",
            "JPY": "JPY",
            "CHF": "CHF",
            "MX\$": "MXN",
            "R\$": "BRL",
            "\$NZ": "NZD",
            "SEK": "SEK",
            "ZAR": "ZAR",
            "\$": "USD",
            "£": "GBP",
            "¥": "JPY",
            "A$": "AUD",
        }
        Object.keys(data).forEach(x => {
            if (str.includes(`${x}`)) {
                str = str.replace(`${x}`, '')
                str = `${str} ${data[x]}`.replace(/\s\s+/g, ' ') //Replace multiple space by one
            }
        })
        return str
    }

    /**
     * Parse HTML to clean result
     * @param {Document} document Document to parse 
     * @returns {IOutputSuccess} Items found
     */
    private _format(document: Document): IOutputSuccess {
        let totalItems: any = document.querySelector('.pagination_total')?.textContent?.split(' ')?.filter((x: any) => x)
        totalItems = parseFloat(totalItems?.[totalItems?.length - 1]?.replace(/(\,|\.|\s)/g, '')) || 0

        return {
            result: [...document.querySelectorAll('table.table_block tbody tr')]?.map(el => {
                let shipping: any = this._convertDevise(el.querySelector('.item_shipping')?.textContent?.replace(/\s+/g, " ")?.split('+')?.[1]?.split(' ')?.[0]!)
                let have: number = parseInt(el.querySelector('.community_summary .community_result:nth-child(1) .community_number')?.textContent!)
                let want: number = parseInt(el.querySelector('.community_summary .community_result:nth-child(2) .community_number')?.textContent!)

                return {
                    title: el.querySelector('.item_description_title')?.textContent,
                    url: `https://www.discogs.com${(<HTMLLinkElement>el.querySelector('a.item_description_title'))?.href}`,
                    labels: [...new Set([...el.querySelectorAll(".label_and_cat a[href^='https://www.discogs.com/']")]?.map(x => x?.textContent))],
                    catnos: el.querySelector('.label_and_cat .item_catno')?.textContent?.replace(/\s+/g, " ")?.split(', ')?.filter(x => x !== 'none'),
                    imageUrl: el.querySelector('.marketplace_image')?.getAttribute('data-src'),
                    description: el.querySelector('.item_description > p.hide_mobile:not(.label_and_cat)')?.textContent?.replace(/\s+/g, " ")?.trim(),
                    isAcceptingOffer: el.querySelector('.item_add_to_cart p strong a')?.textContent?.split("/")?.length! > 1,
                    isAvailable: !el.classList?.contains('unavailable'),
                    condition: {
                        media: {
                            full: el.querySelector('.item_condition span:nth-child(3)')?.textContent?.replace(/\s+/g, " ")?.trim(),
                            short: el.querySelector('.item_condition span:nth-child(3)')?.textContent?.replace(/\s+/g, " ")?.trim()?.match(/\(([^)]+)\)/)?.[1]
                        },
                        sleeve: {
                            full: el.querySelector('.item_condition span.item_sleeve_condition')?.textContent,
                            short: el.querySelector('.item_condition span.item_sleeve_condition')?.textContent?.match(/\(([^)]+)\)/)?.[1]
                        }
                    },
                    seller: {
                        name: el.querySelector('.seller_info a')?.textContent,
                        score: el.querySelector('.seller_info li:nth-child(2) strong')?.textContent,
                        notes: el.querySelector('.seller_info li:nth-child(2) .section_link')?.textContent?.replace(/\s+/g, " ")?.trim()?.split(' ')?.[0]
                    },
                    price: {
                        base: this._convertDevise(el.querySelector('.price')?.textContent?.replace(/\s+/g, " ")?.replace(/,/, '.')!),
                        shipping: isNaN(shipping) ? null : shipping,
                        from: el.querySelector('.seller_info li:nth-child(3)')?.textContent?.split(':')?.[1]
                    },
                    community: {
                        have: isNaN(have) ? null : have,
                        want: isNaN(want) ? null : want
                    },
                    release_url: `https://www.discogs.com${(<HTMLLinkElement>el.querySelector('a.item_release_link'))?.href}`
                }
            }) || [],
            page: {
                current: this.page,
                total: Math.ceil(totalItems / this.limit)
            },
            item: {
                total: totalItems,
                per_page: this.limit,
            },
            search: {
                value: this.searchValue,
                type: this.searchType
            },
            url_generated: this.url
        }
    }
}